scale-xv6作为参考的
优点：
1 一个可以实际在qemu（多核模拟），kvm（多核）和真机（多核）上正常跑的小os
2 识别numa等架构，可支持最新的E7xxx处理器。
3 增加了mtrace（基于qemu进行的扩展，是一个很好的工具），pmc（需要真机支持，即比较新的intel CPU都有）等性能和功能分析工具
4 可以用gdb+qemu来动态调试内核代码

缺点：
1 用了大量的C++特征的代码，理解起来比较费劲（可能是对我而言吧）
2 在初始化阶段有许多与硬件相关的代码，需要有intel架构的系统结构的知识，理解起来比较费劲（但人家基本上写完了，我们大致理解并porting过来即可）
3 用了许多科研性的设计（主要是实现更好的multicore scalability），很新，需要理解后才能port。目前看到的有基于cpu core的物理内存，页表，文件系统等设计。数据结构中能够per cpu的尽量per cpu，能够不lock的，尽量想方设法不lock，能够不引起cache sharing的，尽量不cache sharing. 理解清楚不宜。

推荐方法和步骤：
第一阶段 （除1外，其他部分建议每个同学都做（每人有一个自己的git-tree），当作练手。不过相互间的代码多可以看到和copy等。）
-1 大家阅读ucore for amd64的代码，重点是理解大致的硬件初始化，以及如何实现HAL的。 
0 大家阅读xv6代码，从头开始，不懂的多问（通过maillist等），多自己基于qemu+gdb调试。
1 有amd64架构比较熟悉的同学（一个即可）先完成前期的borting，到能够识别numa架构的CPU，内存，以及完成apic，ioapic等中断相关处理。定义好interface。
2 先完成物理内存的管理，系统只有一个物理内存管理。
3 再完成虚拟内存的管理，所有内存一个虚拟内存管理（即系统只有一个页表）。
4 再完成基本多核调度（基于以前的ucore x86-smp可能就够了） 
5 此时port fs应该比较容易，用一个大锁锁住它即可。

第二阶段 （每1～2个部分由一个同学完成，要求在一个git tree上完成）
6 在尽量保证接口不变的情况下，参考xv6，设计基于每个core的物理内存，虚拟内存，调度管理，RCU同步互斥机制等各个模块。尽量形成各个模块可替换的interface。


